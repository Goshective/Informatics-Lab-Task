# Лабораторная работа 
### Управление вводом/выводом. Конвейерная обработка

## Базовые команды перенаправления ввода-вывода.

1. У консольных программ есть три стандартных потока ввода-вывода: `stdin` (`0`), `stdout` (`1`) и `stderr` (`2`).

Эти потоки можно перенаправлять и комбинировать, например, чтобы вывод одной программы
подавался на вход другой, а ошибки передавались в отдельный файл.

Команда `echo` выведет строку, переданную ей в аргументах прямиком в стандартный вывод.
Можно перенаправить вывод `echo` вместо стандартного вывода в файл:

```bash
echo hello,world! > hello.txt
```

2. Если запустить команду несколько раз, можно заметить что файл `hello.txt` каждый раз перезаписывается.
Чтобы каждый раз добавлять вывод в конец файла, надо использовать `>>` вместо `>`:

```bash
echo hello,world! >> hello.txt
```

3. Можно также, наоборот, перенаправить стандартный ввод и читать данные не из консоли, а из файла.
Возьмём созданный предыдущей командой файл `hello.txt`, и передадим его на вход утилите `grep` для поиска запятых:

```bash
grep "," < hello.txt
```

4. Чтобы перенаправить вывод одной команды на вход другой, можно воспользоваться оператором `|` (`pipe`).
В следующем примере мы подаем в стандартный вывод содержимое файла `hello.txt`, 
стандартный вывод попадает на вход утилите `uniq`, которая оставит от него только уникальные строчки,
и, опять же, передаст на стандартный вывод, который, в свою очередь, будет перехвачен командой `grep`.
Она найдет в этом выводе все запятые и напечатает в `stdout`, уже никем не перехваченный:

```bash
cat hello.txt | uniq | grep ","
```

5. Что если утилита `cat` не найдет файл? Она напечатает ошибку в стандартный вывод ошибок.
Чтобы не смешивать ошибки чтения и содержимое файла, все ошибки можно перенаправлять в отдельный файл, 
или вообще заглушить. В этом примере ошибки пишутся в файл error.txt, а стандартный вывод перехватывается grep:

```bash
cat hello.txt hello2.txt 2> error.txt | grep ","
```

Обратите внимание, что ```cat hello.txt hello2.txt > output.txt``` перенаправит только стандартный вывод в файл `output.txt`,
ошибки продолжат писаться в стандартный вывод ошибок (консоль). Чтобы перенаправить и стандартный вывод, и ошибки
в один файл, можно воспользоваться конструкцией &>. Тут мы направляем стандартный вывод 
в файл `output.txt`, а `stderr` - в `stdout` (порядок важен):

```bash
cat hello.txt hello2.txt > output.txt 2>&1
```

### *Дополнительно*

6. Помимо дескрипторов 0, 1 и 2, можно открывать другие файлы под другими дескрипторами, и использовать их в перенаправлении
ввода-вывода. Например такой скрипт откроет файл `hello.txt` под дескриптором 3, прочитает из него через `grep`, и закроет дескриптор:

```bash
exec 3<> hello.txt
grep "," <&3
exec 3>&-
```


## Задание лабораторной работы

Напишите команду-однострочник, которая пройдется по всем файлам в папке, посчитает в каждом из них количество слов и выведет в файл `result.txt`.
Также все ошибки доступа (если доступ к файлу запрещен) должны быть выведены в файл `errors.txt`.

### Как успешно сдать работу?

Создать свой репозиторий из шаблона этого. Как это делается - "Use this template" -> "Create a new repository" и сделайте его public. 

Находясь уже в своем репозитории - создайте новый файл формата .md и там оформляйте отчет. В отчете опишите все шаги которые вы делали, чтобы получить финальный результат работы. Необходимы только скриншоты скрипта и примера его выполнения!

Что вам нужно знать, чтобы успешно защитить работу:

Виды стандартных потоков, их предназначение; команды ввода/вывода, основные операторы; конвейерная обработка, перенаправление потоков; базовые скрипты.

## Дополнительные источники

1. [Pipe](https://www.gnu.org/software/bash/manual/html_node/Pipelines.html)
2. [Обработка текста](https://se.ifmo.ru/~ad/Documentation/ABS_Guide_ru.html#VARSUBN)
3. stackoverflow.com
